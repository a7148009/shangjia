# 修复方案：商家名和详情页信息提取

## 🔴 问题诊断

### 问题1：商家卡片名称提取错误

**当前提取结果**（错误）：
```
【弗洛伊德】5支家居鲜花瓶插花（不含花瓶）昆明花店仅限到店顾客自取
【念屿蝶序】玫瑰花束蝴蝶兰郁金香蓝星花剑兰混搭花束约会花束生日花束 生日鲜花
```
❌ 这是**商品名称**，不是商家名！

**正确的商家名**（从截图识别）：
```
拂苏花店Floral.昆明
莳度花店(海乐世界店)
```
✅ 这才是**商家名称**（黑色加粗字体）

---

### 问题2：详情页信息提取位置错误

**当前提取逻辑**：
- 从整个页面随机查找文本
- 没有定位到红框区域（商家详情信息区域）

**正确的提取位置**（图3红框区域）：
- 商家名称：页面顶部大标题
- 电话：红框区域的"电话"按钮附近
- 地址：红框区域的地址文本
- 营业时间：红框区域的营业时间文本

---

## 🛠️ 解决方案

### 方案1：修复商家卡片名称提取逻辑

#### 关键发现：
商家卡片的XML结构特征：
1. **商家名**：在ViewGroup的**第一个或第二个**文本节点，且：
   - 长度适中（4-20字符）
   - 字体较大（通常是加粗）
   - 不包含【】、商品描述词
   - Y轴位置在卡片顶部

2. **商品名**：通常：
   - 包含【】、详细描述
   - 长度很长（>30字符）
   - Y轴位置在商家名下方

#### 修复代码：

```python
def _extract_merchant_name(self, node) -> str:
    """
    提取商家名称（2025-01-16完全重构）

    关键特征：
    1. 黑色加粗文字（在卡片顶部）
    2. 长度4-20字符
    3. 不包含【】等商品标识
    4. Y轴位置在卡片上半部分
    """
    bounds = self._parse_bounds(node.get('bounds', ''))
    if not bounds:
        return "未知商家"

    card_top = bounds['y1']
    card_height = bounds['height']

    # 查找所有文本节点
    text_nodes = node.xpath('.//node[@text and string-length(@text) > 0 and @bounds]')

    candidate_names = []

    for text_node in text_nodes:
        text = text_node.get('text', '').strip()

        # 清理HTML标签
        clean_text = re.sub(r'<[^>]+>', '', text).strip()

        if not clean_text or len(clean_text) < 3:
            continue

        # 🆕 关键过滤1：排除商品名特征
        if any(marker in clean_text for marker in ['【', '】', '(', '（']):
            # 但如果只是括号+店名，可能是商家名
            if clean_text.count('(') <= 1 and clean_text.count('（') <= 1:
                if len(clean_text) <= 30:
                    pass  # 可能是商家名，继续检查
                else:
                    continue  # 太长，是商品名
            else:
                continue  # 多个括号，是商品名

        # 🆕 关键过滤2：长度判断（商家名4-30字符）
        if len(clean_text) > 30:
            continue  # 太长，是商品名或描述

        # 🆕 关键过滤3：排除商品描述词
        product_keywords = [
            '花束', '鲜花', '配送', '上门', '店铺', '仅限',
            '不含', '指定', '全国', '实体店', '速递'
        ]
        keyword_count = sum(1 for kw in product_keywords if kw in clean_text)
        if keyword_count >= 3:
            continue  # 包含3个以上商品词，是商品名

        # 🆕 关键过滤4：排除地址和距离
        if self._is_address_text(clean_text):
            continue
        if self._is_excluded_text(clean_text):
            continue
        if self._is_tag_text(clean_text):
            continue

        # 🆕 关键过滤5：Y轴位置（应该在卡片上半部分）
        text_bounds = self._parse_bounds(text_node.get('bounds', ''))
        if text_bounds:
            text_y = text_bounds['y1']
            relative_y = (text_y - card_top) / card_height if card_height > 0 else 1

            # 商家名通常在卡片前30%的位置
            if relative_y > 0.3:
                continue

        # 添加到候选名单
        candidate_names.append({
            'text': clean_text,
            'length': len(clean_text),
            'y_pos': text_bounds['y1'] if text_bounds else 9999
        })

    # 选择最合适的商家名
    if not candidate_names:
        return "未知商家"

    # 排序规则：
    # 1. Y轴位置越靠上越好
    # 2. 长度4-20字符优先
    # 3. 长度适中优先
    candidate_names.sort(key=lambda x: (
        x['y_pos'],                              # Y轴位置最重要
        abs(x['length'] - 10),                   # 长度接近10最好
        -x['length'] if x['length'] <= 20 else x['length']  # 4-20字符优先
    ))

    best_name = candidate_names[0]['text']

    # 最后验证：如果还是太长，取前20个字符
    if len(best_name) > 30:
        best_name = best_name[:20] + "..."

    return best_name
```

---

### 方案2：修复详情页信息提取逻辑

#### 关键发现：
详情页红框区域的XML结构特征：
1. **区域范围**：Y轴大约在400-900之间（屏幕上半部分）
2. **商家名**：最顶部大字（Y=200-500），font-size最大
3. **评分**：3.8分、4.1分等（带有"分"字）
4. **营业时间**：格式"XX:XX-XX:XX"
5. **地址**：包含"区"、"路"、"号"等
6. **电话按钮**：文本包含"电话"或"补充电话"

#### 修复代码：

```python
def _extract_merchant_name_from_detail(self, root, screen_height: int) -> str:
    """
    从商家详情页提取名称（2025-01-16完全重构）

    策略：
    1. 查找Y轴200-600范围内的最大字体文本
    2. 优先HTML格式<font size="XX">
    3. 必须在页面顶部红框区域内
    """
    all_text_nodes = root.xpath('//node[@text and string-length(@text) > 0 and @bounds]')

    candidates = []

    for node in all_text_nodes:
        text = node.get('text', '').strip()
        bounds_str = node.get('bounds', '')

        # 解析bounds
        match = re.match(r'\[(\d+),(\d+)\]\[(\d+),(\d+)\]', bounds_str)
        if not match:
            continue

        x1, y1, x2, y2 = map(int, match.groups())

        # 🆕 关键1：Y轴必须在200-600（商家名区域）
        if not (200 <= y1 <= 600):
            continue

        # 清理HTML，提取字体大小
        font_size = 0
        clean_text = text

        # 尝试提取HTML font标签
        font_match = re.search(r'<font[^>]*size="(\d+)"[^>]*>([^<]+)</font>', text)
        if font_match:
            font_size = int(font_match.group(1))
            clean_text = font_match.group(2).strip()
        else:
            # 没有HTML标签，直接清理
            clean_text = re.sub(r'<[^>]+>', '', text).strip()

        # 🆕 关键2：长度必须在3-30字符（商家名特征）
        if not (3 <= len(clean_text) <= 30):
            continue

        # 🆕 关键3：排除非商家名文本
        if self._is_excluded_text(clean_text):
            continue
        if self._is_address_text(clean_text):
            continue

        # 排除评分（如"3.8 分"）
        if re.match(r'^\d+\.\d+\s*分', clean_text):
            continue

        # 排除时间（如"09:00"）
        if re.match(r'^\d{2}:\d{2}', clean_text):
            continue

        # 排除营业状态
        if clean_text in ['营业中', '休息中', '即将营业']:
            continue

        # 添加到候选
        candidates.append({
            'text': clean_text,
            'font_size': font_size,
            'y_pos': y1,
            'length': len(clean_text)
        })

    if not candidates:
        print("⚠ 未能从详情页提取商家名称")
        return "未知商家"

    # 排序规则：
    # 1. Y轴位置越靠上越好（200-400最佳）
    # 2. 字体越大越好（商家名字体最大）
    # 3. 长度适中（8-20字符最佳）
    candidates.sort(key=lambda x: (
        x['y_pos'],                     # Y轴位置最重要
        -x['font_size'],                # 字体大小第二重要
        abs(x['length'] - 12)           # 长度接近12最好
    ))

    best_name = candidates[0]['text']
    print(f"✓ 从详情页提取商家名: {best_name} (Y={candidates[0]['y_pos']}, 字体={candidates[0]['font_size']})")

    return best_name


def _extract_merchant_info_from_detail_area(self, root, screen_width: int, screen_height: int) -> Dict:
    """
    从详情页红框区域提取信息（2025-01-16新增）

    红框区域特征：
    - Y轴范围：400-1000（大约）
    - 包含：电话按钮、地址、营业时间、评分
    """
    detail_info = {
        'rating': '',
        'business_hours': '',
        'address': '',
        'phone_button_pos': None
    }

    all_text_nodes = root.xpath('//node[@text and string-length(@text) > 0 and @bounds]')

    for node in all_text_nodes:
        text = node.get('text', '').strip()
        clean_text = re.sub(r'<[^>]+>', '', text).strip()
        bounds_str = node.get('bounds', '')

        # 解析bounds
        match = re.match(r'\[(\d+),(\d+)\]\[(\d+),(\d+)\]', bounds_str)
        if not match:
            continue

        x1, y1, x2, y2 = map(int, match.groups())

        # 🆕 只处理红框区域（Y轴400-1000）
        if not (400 <= y1 <= 1000):
            continue

        # 1. 提取评分（X.X 分）
        if not detail_info['rating']:
            rating_match = re.search(r'(\d+\.\d+)\s*分', clean_text)
            if rating_match:
                detail_info['rating'] = rating_match.group(1)
                print(f"  提取评分: {detail_info['rating']}分")

        # 2. 提取营业时间（XX:XX-XX:XX）
        if not detail_info['business_hours']:
            time_match = re.search(r'(\d{2}:\d{2}[-~]\d{2}:\d{2})', clean_text)
            if time_match:
                detail_info['business_hours'] = time_match.group(1)
                print(f"  提取营业时间: {detail_info['business_hours']}")

        # 3. 提取地址（包含区/路/街/号）
        if not detail_info['address']:
            if any(k in clean_text for k in ['区', '路', '街', '号']):
                if len(clean_text) >= 10:
                    detail_info['address'] = clean_text
                    print(f"  提取地址: {detail_info['address']}")

        # 4. 定位电话按钮
        if not detail_info['phone_button_pos']:
            if '电话' in clean_text or '补充电话' in clean_text:
                detail_info['phone_button_pos'] = {
                    'x': (x1 + x2) // 2,
                    'y': (y1 + y2) // 2
                }
                print(f"  定位电话按钮: ({detail_info['phone_button_pos']['x']}, {detail_info['phone_button_pos']['y']})")

    return detail_info
```

---

## 🎯 完整修复步骤

### 步骤1：修复商家名提取（merchant_card_locator.py）
- 替换 `_extract_merchant_name` 方法
- 增加5层过滤逻辑
- 优先选择Y轴靠上、长度适中的文本

### 步骤2：修复详情页提取（merchant_collector.py）
- 替换 `_extract_merchant_name_from_detail` 方法
- 新增 `_extract_merchant_info_from_detail_area` 方法
- 只从红框区域（Y=400-1000）提取信息

### 步骤3：更新采集流程
- 点击后先提取商家名
- 验证名称匹配
- 再提取红框区域详细信息

---

## 📝 预期效果

### 修复前：
```
❌ 卡片识别: 【弗洛伊德】5支家居鲜花瓶插花...
❌ 详情页提取: 达人笔记
❌ 名称不匹配，跳过
```

### 修复后：
```
✅ 卡片识别: 拂苏花店Floral.昆明
✅ 详情页提取: 拂苏花店Floral.昆明
✅ 名称匹配
✅ 提取信息:
   - 评分: 4.1分
   - 营业时间: 10:00-22:00
   - 地址: 官渡区肖家营大棚2期487-488
   - 电话: [点击提取]
```

---

**下一步**：我将立即实施这些修复代码。
