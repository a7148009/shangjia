# 高德地图商家信息采集系统 - 技术文档

**文档版本**: v1.0
**最后更新**: 2025-01-17
**适用系统**: 高德地图商家信息采集系统

---

## 📑 目录

1. [系统概述](#1-系统概述)
2. [分类系统架构](#2-分类系统架构)
3. [页面检测与导航](#3-页面检测与导航)
4. [特殊情况处理](#4-特殊情况处理)
5. [分辨率适配方案](#5-分辨率适配方案)
6. [运行与维护](#6-运行与维护)

---

## 1. 系统概述

### 1.1 系统功能

本系统用于自动化采集高德地图APP中的商家信息，包括：

- ✅ 商家名称
- ✅ 详细地址
- ✅ 联系电话
- ✅ 商家照片

### 1.2 核心技术栈

| 技术 | 说明 |
|------|------|
| **UI自动化** | uiautomator2 - Android设备控制 |
| **XML解析** | lxml + XPath - UI层级解析 |
| **数据库** | SQLite - 分类树形结构存储 |
| **GUI框架** | PyQt6 - 桌面应用界面 |
| **图像管理** | PIL - 商家照片处理 |

### 1.3 采集流程

```
启动高德地图APP
    ↓
搜索目标商家类型（如"鲜花店"）
    ↓
解析商家列表卡片
    ↓
逐个点击进入详情页
    ↓
提取4项核心信息
    ↓
返回列表页继续
    ↓
滑动到下一页
    ↓
重复直到完成
```

---

## 2. 分类系统架构

### 2.1 ID绑定机制

#### 核心设计理念

分类系统使用**数据库自增ID**作为唯一标识，而不是分类名称或路径。

#### 数据库表结构

```sql
CREATE TABLE categories_tree (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- ✅ 永远不变的唯一标识
    name TEXT NOT NULL,                     -- 可以修改
    parent_id INTEGER,                      -- 可以修改
    level INTEGER DEFAULT 0,                -- 自动更新
    path TEXT NOT NULL UNIQUE,              -- 自动更新
    table_name TEXT NOT NULL UNIQUE,        -- 自动更新
    create_time TEXT NOT NULL,
    FOREIGN KEY (parent_id) REFERENCES categories_tree(id)
)
```

**关键点**：
- `id` 是唯一标识，**永远不变**
- `name`, `path`, `table_name` 都可以修改
- 所有关联关系基于 `id` 而非名称

### 2.2 层级支持

系统支持**5级分类**（理论上无限级）：

```
餐饮 (level=0, id=1)
  └─ 中餐 (level=1, id=2)
      └─ 川菜 (level=2, id=3)
          └─ 火锅 (level=3, id=4)
              └─ 麻辣火锅 (level=4, id=5)
```

**层级关系**：
- 通过 `parent_id` 关联父级分类
- 通过 `level` 标识层级深度
- 通过 `path` 记录完整路径（如"餐饮/中餐/川菜"）

### 2.3 分类重命名机制

#### 操作流程

```python
def update_category(category_id, new_name):
    # 1. 获取当前分类信息
    old_name, parent_id, level, old_path, old_table_name = get_category(category_id)

    # 2. 计算新路径
    new_path = calculate_new_path(parent_id, new_name)
    new_table_name = f"merchants_{new_path.replace('/', '_')}"

    # 3. 更新分类信息（ID不变！）
    UPDATE categories_tree
    SET name = new_name, path = new_path, table_name = new_table_name
    WHERE id = category_id

    # 4. 重命名商家表（数据完整保留！）
    ALTER TABLE old_table_name RENAME TO new_table_name

    # 5. 更新关联表引用
    UPDATE phones SET table_name = new_table_name WHERE table_name = old_table_name
    UPDATE images SET table_name = new_table_name WHERE table_name = old_table_name

    # 6. 递归更新所有子孙分类的路径
    update_descendant_paths(category_id, old_path, new_path)
```

#### 数据完整性保障

**重要**：`ALTER TABLE ... RENAME TO ...` 操作会**完整保留**表中的所有数据！

**示例**：
```
重命名前：
  - 分类ID: 2 (不变)
  - 分类名称: 鲜花
  - 路径: 昆明/鲜花
  - 表名: merchants_昆明_鲜花
  - 表中数据: 50条商家记录

重命名后：
  - 分类ID: 2 (不变！)
  - 分类名称: 青羊区
  - 路径: 昆明/青羊区
  - 表名: merchants_昆明_青羊区
  - 表中数据: 50条商家记录 (完全保留！)
```

### 2.4 关联表结构

#### phones表（电话记录）

```sql
CREATE TABLE phones (
    id INTEGER PRIMARY KEY,
    merchant_id INTEGER NOT NULL,     -- 商家ID
    table_name TEXT NOT NULL,         -- 所属分类表名
    phone TEXT NOT NULL
)
```

#### images表（图片记录）

```sql
CREATE TABLE images (
    id INTEGER PRIMARY KEY,
    merchant_id INTEGER NOT NULL,     -- 商家ID
    table_name TEXT NOT NULL,         -- 所属分类表名
    image_path TEXT NOT NULL
)
```

**关键点**：
- `merchant_id` 在各分类表内唯一
- `table_name` 用于区分不同分类的商家
- 重命名时 `table_name` 会自动更新

### 2.5 ID绑定的优势

| 操作 | ID绑定系统 | 名称绑定系统 |
|------|-----------|--------------|
| 重命名分类 | ✅ 数据完整保留 | ❌ 数据丢失或混乱 |
| 移动分类 | ✅ 数据自动跟随 | ❌ 需要手动迁移 |
| 查询效率 | ✅ 整数比较快速 | ❌ 字符串比较慢 |
| 路径变化 | ✅ 自动级联更新 | ❌ 需要重新关联 |
| 唯一性 | ✅ 数据库自动保证 | ❌ 需要手动检查 |

### 2.6 最佳实践

#### 分类命名规范
- 使用清晰明确的名称
- 避免使用特殊字符（会影响表名生成）
- 同级分类名称不重复

#### 数据采集建议
1. 先创建完整的分类树结构
2. 再进行数据采集
3. 定期备份数据库文件 `merchants.db`

#### 重命名注意事项
- 重命名分类后，旧的路径名称不再有效
- 在主窗口的分类选择器中需要重新选择分类
- 已采集的数据会自动关联到新名称

---

## 3. 页面检测与导航

### 3.1 返回商家列表页逻辑

#### 核心方法：`go_back_to_list()`

**位置**: `merchant_collector.py` 第445-481行

#### 完整流程图

```
采集商家详情完成
    ↓
调用 go_back_to_list()
    ↓
┌─────────────────────────────────┐
│ 第1次按返回键                    │
│ self.adb_manager.press_back()   │
│ (使用Android系统返回键)          │
│ time.sleep(1.5)                 │
└─────────────────────────────────┘
    ↓
┌──────────────────────────────────┐
│ 检查当前页面类型                  │
│ （基于UI层级XML解析）            │
└──────────────────────────────────┘
    ↓
    ├─→ 情况1：搜索结果页？
    │   （检测：顶部标题 + 筛选按钮）
    │       ↓ YES
    │   ✅ 成功返回 → return True
    │
    ├─→ 情况2：商家详情页？
    │   （仍在详情页，可能有弹窗）
    │       ↓ YES
    │   ⚠️ 再次按返回键
    │       ↓
    │   第2次按返回键
    │   time.sleep(1.5)
    │       ↓
    │   再次检查是否回到搜索结果页
    │       ├─→ YES → ✅ 成功返回
    │       └─→ NO → ❌ 返回失败
    │
    └─→ 情况3：其他页面？
        （可能回到首页）
            ↓
        ❌ 返回到未知页面 → return False
```

### 3.2 按返回键实现

**位置**: `adb_manager.py` 第213-226行

```python
def press_back(self):
    """按返回键"""
    if not self.u2_device:
        return

    try:
        # 核心：调用uiautomator2的按键方法
        self.u2_device.press("back")
        time.sleep(0.5)

        # 记录屏幕状态（如果启用了屏幕日志）
        self._log_screen_state("按返回键")

    except Exception as e:
        print(f"按返回键失败: {e}")
```

**关键点**：
- 使用 **uiautomator2** 的 `press("back")` 方法
- 这等同于按下 **Android系统的返回键**
- **不是点击UI上的返回按钮**，而是系统级别的按键事件
- 发送 `KEYCODE_BACK` 事件给Android系统

### 3.3 页面检测机制

#### A. 搜索结果列表页检测

**位置**: `merchant_collector.py` 第767-849行

**页面布局**：

```
┌─────────────────────────────────┐
│ [<] 成都全午区鲜花店  [🔍] [✕]  │ ← 顶部标题栏
│ 🔥 附近上榜  九里堤附近  ...    │ ← ✅ 关键标识！
│ [筛选] [排序]                   │ ← ✅ 关键按钮
├─────────────────────────────────┤
│ [商家卡片1]                     │
│ [商家卡片2]                     │
└─────────────────────────────────┘
```

**检测特征**：

##### 特征1：顶部标题区域（最关键）

```python
# 在Y轴 < 300的顶部区域查找关键词
top_title_keywords = ['附近上榜', '榜单', '推荐商家', '附近商家', '搜索结果']

for node in top_area_nodes:
    if y1 < 300:  # 顶部区域
        for keyword in top_title_keywords:
            if keyword in text:
                has_top_title = True
```

##### 特征2：筛选按钮
- 搜索包含"筛选"文本的节点
- XPath: `//node[contains(@text, "筛选")]`

##### 特征3：排序按钮
- 搜索包含"排序"文本的节点
- XPath: `//node[contains(@text, "排序")]`

##### 特征4：RecyclerView
- 检测商家列表容器
- XPath: `//node[@class="androidx.recyclerview.widget.RecyclerView"]`

**综合判断**：

```python
# 方案1（最可靠）：顶部标题 + 筛选按钮
is_search_page_v1 = has_top_title and has_filter

# 方案2（兼容旧版）：筛选 + 排序 + RecyclerView
is_search_page_v2 = has_filter and has_sort and has_recyclerview

# 最终判断：满足任一方案即可
is_search_page = is_search_page_v1 or is_search_page_v2
```

#### B. 商家详情页检测

**位置**: `merchant_collector.py` 第652-765行

**页面布局**：

```
┌─────────────────────────────────┐
│ [<] 花满庭鲜花  [🔍] [❗] [✕]   │ ← ✅ 右上角3个按钮（关键）
│                                 │    搜索 + 反馈 + 关闭
│ 📸 [商家照片区域]                │
│                                 │
│ 花满庭鲜花（花开相爱旗舰店）    │ ← 商家名称
│ 四川省成都市金牛区...           │ ← 地址
│ [电话] [导航] [收藏]            │ ← ✅ 操作按钮
└─────────────────────────────────┘
```

**检测特征**：

##### 特征1：右上角3个按钮（最关键）

```python
# 在右上角区域（X > 70%屏宽, Y < 200）查找3个按钮
if x1 > screen_width * 0.7 and y1 < 200:
    # 1. 搜索按钮（放大镜图标）
    if '搜索' in content_desc or 'search' in content_desc.lower():
        has_search_btn = True

    # 2. 反馈按钮（感叹号图标）
    if '反馈' in content_desc or 'feedback' in content_desc.lower():
        has_feedback_btn = True

    # 3. 关闭/更多按钮
    if '关闭' in content_desc or '更多' in content_desc:
        has_close_btn = True

# 至少检测到2个按钮（因为可能有识别失败）
has_top_right_buttons = (has_search_btn and has_feedback_btn) or \
                       (has_search_btn and has_close_btn) or \
                       (has_feedback_btn and has_close_btn)
```

##### 特征2：电话按钮（核心）
- 必须有电话按钮，才是有效商家
- XPath: `//node[contains(@text, "电话") or contains(@content-desc, "电话")]`

##### 特征3：导航按钮
- 导航或路线按钮
- XPath: `//node[contains(@text, "导航") or contains(@text, "路线")]`

##### 排除特征
- ❌ 不能有"筛选"按钮（排除搜索结果页）
- ❌ 不能有"排序"按钮（排除搜索结果页）
- ❌ 不能有"推荐"、"服务推荐"等广告关键词

**综合判断**：

```python
# 方案1（最可靠）：右上角3按钮 + 电话按钮
is_detail_page_v1 = has_top_right_buttons and has_phone

# 方案2（兼容旧版）：电话 + 导航（且无筛选/排序）
is_detail_page_v2 = has_phone and has_nav and not has_filter and not has_sort

# 最终判断：满足任一方案，且不是广告页
is_detail_page = (is_detail_page_v1 or is_detail_page_v2) and not is_ad_page
```

### 3.4 设计理念

#### 1. 使用系统返回键而非点击UI按钮

**原因**：
- ✅ **通用性**：所有Android页面都支持返回键
- ✅ **可靠性**：系统级事件，不受UI布局变化影响
- ✅ **速度快**：直接发送按键事件，无需查找UI元素
- ❌ 点击UI按钮的问题：
  - UI元素位置可能变化
  - 需要先查找元素（耗时）
  - 可能被其他元素遮挡

#### 2. 智能页面检测

**原因**：
- ✅ **容错性**：可能有弹窗、广告等干扰
- ✅ **准确性**：多重特征判断，降低误判率
- ✅ **兼容性**：多方案判断，适配不同版本高德地图

#### 3. 两次返回尝试

**原因**：
- 第一次返回可能只是关闭弹窗（如电话弹窗、补充电话弹窗）
- 第二次返回才能真正回到列表页
- 避免因弹窗导致返回失败

### 3.5 检测准确率

| 页面类型 | 新增关键特征 | 位置 | 准确率 |
|---------|------------|------|--------|
| 搜索结果页 | "附近上榜"标题 | Y < 300 | ⭐⭐⭐⭐⭐ 95%+ |
| 商家详情页 | 右上角3按钮 | X>70%, Y<200 | ⭐⭐⭐⭐⭐ 95%+ |

### 3.6 调试日志输出

**搜索结果页检测**：
```
✓ 检测到顶部标题特征: '附近上榜' (Y=150)
✓ 确认在搜索结果页（检测到顶部标题）
```

**商家详情页检测**：
```
✓ 检测到搜索按钮 (X=950, Y=80)
✓ 检测到反馈按钮 (X=1000, Y=80)
✓ 检测到关闭/更多按钮 (X=1050, Y=80)
✓ 确认在商家详情页（检测到右上角3按钮）
```

---

## 4. 特殊情况处理

### 4.1 咨询按钮跳转拨号页面

#### 问题描述

某些商家的电话按钮上带有"咨询"文字，点击后不会弹出电话号码弹窗，而是直接跳转到系统拨号页面。

**问题特征**：
- **正常情况**：点击电话按钮 → 弹出电话号码弹窗 → 提取号码
- **特殊情况**：点击电话按钮（带"咨询"） → 直接跳转拨号页面 → 无法提取号码

#### 解决方案

##### 核心思路

1. **检测拨号页面** - 点击电话按钮后，检测是否跳转到拨号页面
2. **返回特殊标记** - 如果是拨号页面，返回 `None` 作为特殊标记
3. **跳过当前商家** - 主流程检测到 `None`，跳过此商家，继续下一个

##### 实现流程

```
点击电话按钮
    ↓
检测页面类型
    ↓
┌─────────────────┐
│ 是拨号页面？    │
└─────────────────┘
    ↓ 是          ↓ 否
返回None      提取电话号码
    ↓              ↓
跳过商家      正常采集
```

##### 拨号页面检测方法

**位置**: `merchant_collector.py` 第855-908行

```python
def _is_on_dialer_page(self) -> bool:
    """
    检测是否在拨号页面

    拨号页面特征：
    - 包含拨号盘（数字按钮0-9）
    - 包含拨号操作元素（如"通话"、"拨号"）
    - 不是高德地图界面（没有商家信息元素）
    """
    # 特征1：拨号盘数字
    digit_buttons = root.xpath('//node[@clickable="true" and (@text="1" or @text="2")]')
    has_dialer_digits = len(digit_buttons) > 0

    # 特征2：拨号相关文本
    dialer_keywords = ['拨号', '通话', '呼叫', '联系人', '最近通话', '通讯录']
    has_dialer_text = False
    for keyword in dialer_keywords:
        if len(root.xpath(f'//node[contains(@text, "{keyword}")]')) > 0:
            has_dialer_text = True
            break

    # 特征3：排除高德地图元素
    amap_keywords = ['商家', '导航', '路线', '地址', '详情']
    has_amap_elements = False
    for keyword in amap_keywords:
        if len(root.xpath(f'//node[contains(@text, "{keyword}")]')) > 0:
            has_amap_elements = True
            break

    # 判断：有拨号盘或拨号文本，且没有高德地图元素
    is_dialer = (has_dialer_digits or has_dialer_text) and not has_amap_elements

    return is_dialer
```

##### 电话提取方法增加检测

**位置**: `merchant_collector.py` 第1123-1168行

```python
def _click_and_extract_phone_at_pos(self, phone_button_pos: Dict) -> List[str]:
    """
    Returns:
        电话号码列表，如果跳转到拨号页面则返回None（特殊标记）
    """
    try:
        # 点击电话按钮
        self.adb_manager.click(phone_button_pos['x'], phone_button_pos['y'])
        print(f"✓ 点击电话按钮: ({phone_button_pos['x']}, {phone_button_pos['y']})")
        time.sleep(1.5)

        # 🆕 关键检查：是否跳转到拨号页面
        if self._is_on_dialer_page():
            print(f"  ⚠ 检测到拨号页面（电话按钮带'咨询'），无法提取号码")
            print(f"  → 返回商家列表，跳过此商家")
            # 返回None作为特殊标记
            self.adb_manager.press_back()
            time.sleep(0.5)
            return None  # ← 关键：返回None

        # 提取电话号码
        phones = self._extract_phone_numbers()

        # 关闭电话弹窗
        self.adb_manager.press_back()
        time.sleep(0.5)

        return phones
```

##### 主采集流程跳过咨询商家

**位置**: `merchant_collector.py` 第564-569行

```python
# 4. 采集商家详情
detail_data = self.collect_merchant_detail(merchant_name)

# 🆕 检查特殊情况：电话按钮为咨询类型（返回None）
if detail_data is None:
    print(f"    ⚠ 商家电话为咨询类型，跳过此商家")
    # 不计入采集失败，直接跳过
    self.go_back_to_list()
    continue  # ← 关键：跳过此商家，继续下一个
```

#### 执行流程对比

**正常流程（有电话号码）**：
```
点击电话按钮
    ↓
弹出电话号码弹窗
    ↓
提取电话号码 → 返回 ['18685488479']
    ↓
商家详情采集成功
    ↓
保存商家数据
    ↓
继续下一个商家
```

**特殊流程（咨询按钮）**：
```
点击电话按钮（带"咨询"）
    ↓
跳转到系统拨号页面
    ↓
检测到拨号页面 → 返回 None
    ↓
商家详情返回 None
    ↓
主流程检测到 None
    ↓
打印"商家电话为咨询类型，跳过此商家"
    ↓
返回商家列表页
    ↓
continue 跳过 → 继续下一个商家
```

#### 日志输出示例

**正常情况**：
```
✓ 点击电话按钮: (950, 350)
从HTML标签提取到电话: 18685488479
    ✓ 成功采集: 热植花卉
      电话: 18685488479
      地址: 昆明市呈贡区斗南花卉市场A区35-38号
```

**特殊情况（咨询按钮）**：
```
✓ 点击电话按钮: (950, 350)
✓ 检测到拨号页面 (拨号盘:True, 拨号文本:True)
  ⚠ 检测到拨号页面（电话按钮带'咨询'），无法提取号码
  → 返回商家列表，跳过此商家
  ⚠ 电话按钮为咨询类型，返回None跳过此商家
    ⚠ 商家电话为咨询类型，跳过此商家
✓ 已返回搜索结果页

  [2/4] 正在处理: 花悦花卉
...
```

### 4.2 补充电话弹窗检测

#### 问题描述

某些商家未在高德地图留电话号码，点击电话按钮会弹出"补充电话"弹窗。

#### 检测方法

**位置**: `merchant_collector.py` 第910-943行

```python
def _is_supplement_phone_dialog(self) -> bool:
    """
    检测是否是"补充电话"弹窗

    补充电话弹窗特征：
    - 包含"补充电话"文本
    - 表示商家未提供电话号码
    """
    try:
        xml_content = self.adb_manager.get_ui_hierarchy()
        if not xml_content:
            return False

        root = etree.fromstring(xml_content.encode('utf-8'))

        # 检测"补充电话"相关文本
        supplement_keywords = ['补充电话', '暂无电话', '未提供电话', '添加电话']
        has_supplement_text = False

        for keyword in supplement_keywords:
            if len(root.xpath(f'//node[contains(@text, "{keyword}")]')) > 0:
                has_supplement_text = True
                print(f"✓ 检测到补充电话弹窗 (关键词:{keyword})")
                break

        return has_supplement_text

    except Exception as e:
        print(f"补充电话弹窗检测失败: {e}")
        return False
```

#### 处理逻辑

```python
# 点击电话按钮后检查
if self._is_supplement_phone_dialog():
    print(f"  ⚠ 检测到'补充电话'弹窗（商家未留电话）")
    print(f"  → 返回商家列表，跳过此商家")
    self.adb_manager.press_back()
    time.sleep(0.5)
    return None
```

### 4.3 广告服务卡片过滤

#### 问题描述

"鲜花上门配送"等广告服务卡片中的"电话预定"按钮不是商家本身的电话。

#### 检测方法

**位置**: `merchant_collector.py` 第1031-1102行

```python
def _is_ad_service_node(self, node) -> bool:
    """
    检测节点是否属于广告服务卡片

    广告服务卡片特征：
    - 节点本身或父级节点包含广告服务关键词
    - 例如："鲜花上门配送"、"配送服务"、"服务推荐"等
    """
    try:
        # 广告服务关键词
        ad_service_keywords = [
            '鲜花上门配送', '上门配送', '配送服务', '鲜花配送',
            '送货上门', '配送推荐', '服务推荐', '推荐服务',
            '场地布置', '气球派对', '开业花篮',
            '买花榜', '服务', '推荐'
        ]

        # 1. 检查当前节点的文本
        text = node.get('text', '').strip()
        content_desc = node.get('content-desc', '').strip()

        for keyword in ad_service_keywords:
            if keyword in text or keyword in content_desc:
                return True

        # 2. 检查父级节点（向上查找2层）
        parent = node.getparent()
        if parent is not None:
            parent_text = parent.get('text', '').strip()
            parent_desc = parent.get('content-desc', '').strip()

            for keyword in ad_service_keywords:
                if keyword in parent_text or keyword in parent_desc:
                    return True

            # 再向上查找一层
            grandparent = parent.getparent()
            if grandparent is not None:
                gp_text = grandparent.get('text', '').strip()
                gp_desc = grandparent.get('content-desc', '').strip()

                for keyword in ad_service_keywords:
                    if keyword in gp_text or keyword in gp_desc:
                        return True

        # 3. 检查同级兄弟节点（可能包含服务卡片标题）
        parent = node.getparent()
        if parent is not None:
            siblings = parent.xpath('.//node[@text or @content-desc]')
            for sibling in siblings:
                if sibling == node:
                    continue

                sib_text = sibling.get('text', '').strip()
                sib_desc = sibling.get('content-desc', '').strip()

                for keyword in ad_service_keywords:
                    if keyword in sib_text or keyword in sib_desc:
                        return True

        return False

    except Exception as e:
        return False
```

#### 过滤层级

| 过滤层级 | 过滤内容 | 检测方法 |
|---------|---------|---------|
| **第1层** | 非拨号按钮文字 | 文字匹配：['补充电话', '添加电话', '电话预定' 等] |
| **第2层** | 系统UI元素 | namespace匹配：com.android.systemui:*, android:id/* |
| **第3层** | Y轴位置异常 | 坐标验证：Y必须在200-1500范围 |
| **第4层** | 广告服务卡片 | 节点树检测：父级+兄弟节点包含服务关键词 |

---

## 5. 分辨率适配方案

### 5.1 问题分析

之前的代码使用**硬编码的像素值**，导致换手机后定位失败：

```python
# ❌ 旧代码 - 硬编码像素值
self.zones = {
    'name_area': {'y_min': 600, 'y_max': 800},    # 只适配1080x2400
    'info_area': {'y_min': 800, 'y_max': 1200},
}
```

**问题**：换成其他分辨率（如720x1600、1440x3200），区域会错位！

### 5.2 解决方案

使用**相对屏幕高度的比例**（百分比），自动适配所有分辨率：

```python
# ✅ 新代码 - 使用比例
self.zone_ratios = {
    'name_area': {'y_min': 0.25, 'y_max': 0.35},    # 25%-35%屏幕高度
    'info_area': {'y_min': 0.35, 'y_max': 0.55},    # 35%-55%屏幕高度
}

# 初始化时自动计算实际像素值
self.zones['name_area']['y_min'] = int(screen_height * 0.25)
self.zones['name_area']['y_max'] = int(screen_height * 0.35)
```

### 5.3 适配效果对比

#### 测试机 1080x2400

**商家列表区域**：
```
📱 屏幕尺寸: 1080x2400
📐 商家列表区域:
   Y轴范围: 480-1800 像素 (20%-75%屏幕高度)
```

**商家详情区域**：
```
📱 屏幕尺寸: 1080x2400
📐 区域划分:
   照片区域: Y=192-600      (8%-25%)
   商家名区域: Y=600-840     (25%-35%)
   信息区域: Y=840-1320     (35%-55%)
```

#### 小屏手机 720x1600

**商家列表区域**：
```
📱 屏幕尺寸: 720x1600
📐 商家列表区域:
   Y轴范围: 320-1200 像素 (20%-75%屏幕高度)
```

**商家详情区域**：
```
📱 屏幕尺寸: 720x1600
📐 区域划分:
   照片区域: Y=128-400      (8%-25%)
   商家名区域: Y=400-560     (25%-35%)
   信息区域: Y=560-880      (35%-55%)
```

#### 大屏手机 1440x3200

**商家列表区域**：
```
📱 屏幕尺寸: 1440x3200
📐 商家列表区域:
   Y轴范围: 640-2400 像素 (20%-75%屏幕高度)
```

**商家详情区域**：
```
📱 屏幕尺寸: 1440x3200
📐 区域划分:
   照片区域: Y=256-800      (8%-25%)
   商家名区域: Y=800-1120    (25%-35%)
   信息区域: Y=1120-1760    (35%-55%)
```

### 5.4 适配原理

#### 屏幕区域划分

```
屏幕高度 = 100%
┌─────────────────────────────────┐
│  0% - 顶部状态栏                 │
│  ├─────────────────────────────┤
│  8% - 照片区域开始               │  ← 详情页
│  ├─────────────────────────────┤
│  20% - 商家列表区域开始          │  ← 搜索结果页
│  ├─────────────────────────────┤
│  25% - 商家名区域开始            │  ← 详情页
│  ├─────────────────────────────┤
│  35% - 信息区域开始（红框）      │  ← 详情页
│  ├─────────────────────────────┤
│  55% - 信息区域结束              │
│  ├─────────────────────────────┤
│  75% - 商家列表区域结束          │
│  ├─────────────────────────────┤
│  85% - 内容区域结束              │
│  ├─────────────────────────────┤
│  100% - 底部导航栏               │
└─────────────────────────────────┘
```

#### 为什么用比例？

1. **APP布局是响应式的**
   - 高德地图APP在不同分辨率下，布局比例是相同的
   - 商家名总是在详情页的25%-35%高度
   - 红框信息总是在35%-55%高度

2. **像素值会错位**
   - 720x1600的600像素 = 37.5%高度
   - 1440x3200的600像素 = 18.75%高度
   - 同样的600像素，在不同分辨率意义完全不同！

3. **比例保持一致**
   - 720x1600的25% = 400像素
   - 1440x3200的25% = 800像素
   - 都能准确定位到商家名区域！

### 5.5 配置文件

**位置**: `config.yaml`

```yaml
# 商家卡片识别参数
merchant_card:
  safe_y_min_ratio: 0.20  # 商家列表区域最小Y轴比例（20%屏幕高度）
  safe_y_max_ratio: 0.75  # 商家列表区域最大Y轴比例（75%屏幕高度）

# 商家详情定位参数
merchant_detail:
  zone_ratios:
    photo_area:
      y_min: 0.08
      y_max: 0.25
    name_area:
      y_min: 0.25
      y_max: 0.35
    info_area:
      y_min: 0.35
      y_max: 0.55
```

---

## 6. 运行与维护

### 6.1 运行脚本

#### run.bat

**位置**: 项目根目录

**功能**: 启动主程序图形界面

```batch
@echo off
python main_window.py
pause
```

**执行流程**：
```
run.bat
  │
  ├──> 执行: python main_window.py
  │
  └──> main_window.py (图形界面程序)
         │
         ├──> 使用: MerchantCollector (采集器)
         │
         └──> 调用: merchant_collector.py
```

#### view_data.bat

**位置**: 项目根目录

**功能**: 启动数据查看器

```batch
@echo off
python data_viewer.py
pause
```

### 6.2 核心文件说明

| 文件 | 功能 | 位置 |
|------|------|------|
| `main_window.py` | 主窗口界面 | 根目录 |
| `merchant_collector.py` | 商家信息采集核心逻辑 | 根目录 |
| `merchant_card_locator.py` | 商家卡片精确定位 | 根目录 |
| `merchant_detail_locator.py` | 商家详情信息提取 | 根目录 |
| `category_manager.py` | 分类树形管理 | 根目录 |
| `adb_manager.py` | ADB设备管理 | 根目录 |
| `database.py` | 数据库操作 | 根目录 |
| `image_manager.py` | 图片管理 | 根目录 |
| `data_viewer.py` | 数据查看器 | 根目录 |
| `config.yaml` | 系统配置文件 | 根目录 |
| `merchants.db` | 商家数据库 | 根目录 |

### 6.3 常见问题

#### Q1: 返回后仍在详情页？

**原因**：可能有弹窗未关闭（如电话弹窗）

**解决方案**：
- 系统会自动检测并执行第2次返回
- 查看日志："⚠ 仍在商家详情页，尝试再次返回"

#### Q2: 返回到了首页？

**原因**：连续按了过多次返回键

**解决方案**：
- 系统会检测并给出警告："⚠ 返回到了未知页面，可能已回到首页"
- 需要手动回到搜索结果页重新开始

#### Q3: 页面检测失败？

**原因**：高德地图版本不同，UI布局变化

**解决方案**：
- 系统使用多方案判断，兼容性强
- 如果新特征检测失败，会自动使用旧特征
- 如果都失败，请反馈具体情况

#### Q4: 商家名不匹配？

**原因**：点击了广告卡片或识别错误

**解决方案**：
- 系统会自动验证商家名
- 不匹配时会跳过，继续下一个
- 查看日志："✗ 商家名不匹配！"

### 6.4 数据备份

**建议**：定期备份以下文件

- `merchants.db` - 商家数据库
- `merchant_images/` - 商家图片文件夹
- `config.yaml` - 配置文件

**备份命令**：
```batch
xcopy merchants.db backup\ /Y
xcopy merchant_images backup\merchant_images\ /E /I /Y
xcopy config.yaml backup\ /Y
```

### 6.5 调试模式

**启用方式**：修改 `config.yaml`

```yaml
debug_mode:
  enabled: true                      # 启用调试模式
  save_card_screenshots: true        # 保存商家卡片截图
  screenshot_dir: ./debug_screenshots  # 截图保存目录
  pause_before_click: true           # 点击前暂停
  pause_duration: 2                  # 暂停时长（秒）
```

**调试输出示例**：
```
==================================================
🔍 开始解析商家卡片列表
==================================================
  ✓ 检测到搜索按钮 (X=950, Y=80)
  ✓ 检测到反馈按钮 (X=1000, Y=80)
  ✓ 确认在商家详情页（检测到右上角3按钮）
  ✓ 商家名: 花满庭鲜花 (Y=650, 字体=48)
  ✓ 电话按钮: (950, 1200) (resource-id=...)
  📸 截图已保存: ./debug_screenshots/merchant_list_20250117_143022.png
==================================================
✓ 解析完成，共识别 4 个商家卡片
==================================================
```

---

## 附录A：技术细节

### A1. XML解析流程

```python
# 1. 获取UI层级XML
xml_content = self.adb_manager.get_ui_hierarchy()

# 2. 解析XML
from lxml import etree
root = etree.fromstring(xml_content.encode('utf-8'))

# 3. 使用XPath查找元素
nodes = root.xpath('//node[@text and @bounds]')

# 4. 解析bounds坐标
match = re.match(r'\[(\d+),(\d+)\]\[(\d+),(\d+)\]', bounds_str)
x1, y1, x2, y2 = map(int, match.groups())

# 5. 判断位置和内容
if y1 < 300:  # 顶部区域
    if '附近上榜' in text:
        has_top_title = True
```

### A2. 电话号码提取

**策略1：HTML标签提取**
```python
# 移除HTML标签，获取纯文本
clean_text = re.sub(r'<[^>]+>', '', text).strip()

# 匹配11位手机号
phone_pattern = r'1[3-9]\d{9}'
matches = re.findall(phone_pattern, clean_text)
```

**策略2：正则匹配**
```python
phone_patterns = [
    r'1[3-9]\d{9}',          # 11位手机号
    r'0\d{2,3}-?\d{7,8}',    # 固定电话
]

for pattern in phone_patterns:
    matches = re.findall(pattern, text)
```

### A3. 表名生成规则

```python
def get_table_name(path: str) -> str:
    """
    路径: "餐饮/中餐/川菜"
    表名: "merchants_餐饮_中餐_川菜"
    """
    safe_path = path.replace('/', '_').replace(' ', '_').lower()
    return f"merchants_{safe_path}"
```

---

## 附录B：更新日志

### v1.0 (2025-01-17)

#### 新增功能
- ✅ 完整的分类树形系统
- ✅ 智能页面检测机制
- ✅ 特殊情况处理（咨询按钮、补充电话）
- ✅ 分辨率自动适配
- ✅ 广告服务卡片过滤

#### 优化改进
- ✅ 使用系统返回键替代UI点击
- ✅ 多方案页面检测（准确率95%+）
- ✅ ID绑定分类系统
- ✅ 比例化分辨率适配

#### 文档更新
- ✅ 合并5个技术文档
- ✅ 重新组织结构
- ✅ 添加流程图和示例
- ✅ 完善调试说明

---

## 附录C：参考资料

### 相关代码文件

- `merchant_collector.py` - 商家信息采集核心逻辑
- `category_manager.py` - 分类树形管理
- `merchant_card_locator.py` - 商家卡片精确定位
- `merchant_detail_locator.py` - 商家详情信息提取
- `adb_manager.py` - ADB设备管理

### 配置文件

- `config.yaml` - 系统配置参数
- `requirements.txt` - Python依赖包

### 数据库

- `merchants.db` - 商家数据存储
- 分类树表：`categories_tree`
- 商家表：`merchants_[分类路径]`
- 电话表：`phones`
- 图片表：`images`

---

**文档编写**: Claude Code
**最后更新**: 2025-01-17
**版本**: v1.0
